/**
 * TypeScript API type definitions for OntoSight visualization engine.
 *
 * These types mirror the Pydantic models defined in the Python backend.
 * Generated to match ontosight/models.py and ontosight/server/models/api.py
 *
 * Contract Alignment:
 * - Node<T> ↔ Pydantic Node[T]
 * - Edge<T> ↔ Pydantic Edge[T]
 * - HyperEdge<T> ↔ Pydantic HyperEdge[T]
 *
 * All types support JSON serialization and are used for API request/response
 * validation.
 *
 * Archived Types (Phase 7+ features):
 * - TreeNode<T> - Backend support planned for tree visualization
 * - TreeData - Backend support planned for tree visualization
 * - TableData - Merged into list visualization
 */

/**
 * Generic node for graph visualization.
 * 
 * @template T - Type of domain-specific data
 * 
 * @example
 * const node: Node<PersonData> = {
 *   id: "person_1",
 *   data: { label: "Alice (age 30)", raw: { name: "Alice", age: 30 } }
 * };
 */
export interface Node<T> {
  /** Unique node identifier within the graph */
  id: string;
  /** Whether this node should be highlighted (persistent search result) */
  highlighted?: boolean;
  /** Domain-specific data with label and raw fields */
  data: {
    /** Display label for UI rendering */
    label: string;
    /** Original object data */
    raw: T;
    /** Additional G6 properties (x, y, style, etc.) */
    [key: string]: any;
  };
}

/**
 * Generic edge connecting two nodes.
 * 
 * @template T - Type of edge metadata
 * 
 * @example
 * const edge: Edge<RelationData> = {
 *   id: "edge_1",
 *   source: "person_1",
 *   target: "person_2",
 *   data: { label: "friend since 2020", raw: { relation: "friend", since: 2020 } }
 * };
 */
export interface Edge<T> {
  /** Unique edge identifier */
  id: string;
  /** Source node identifier */
  source: string;
  /** Target node identifier */
  target: string;
  /** Whether this edge should be highlighted (persistent search result) */
  highlighted?: boolean;
  /** Edge metadata with label and raw fields */
  data: {
    /** Display label for edge */
    label: string;
    /** Original edge data */
    raw: T;
    /** Additional G6 properties */
    [key: string]: any;
  };
}

/**
 * Generic item for list/table visualization.
 * 
 * @template T - Type of item data
 * 
 * @example
 * const item: Item<PersonData> = {
 *   id: "person_1",
 *   data: { label: "Alice", raw: { name: "Alice", age: 30 } }
 * };
 */
export interface Item<T> {
  /** Unique item identifier */
  id: string;
  /** Whether this item should be highlighted (persistent search result) */
  highlighted?: boolean;
  /** Item data with label and raw fields */
  data: {
    /** Display label */
    label: string;
    /** Original item data */
    raw: T;
    /** Additional properties */
    [key: string]: any;
  };
}

/**
 * Multi-node edge connecting more than 2 nodes.
 * Used for hypergraph visualization.
 * 
 * @template T - Type of hyperedge metadata
 * 
 * @example
 * const hyperedge: Hyperedge<ProjectData> = {
 *   id: "he_123",
 *   node_list: ["researcher_1", "researcher_2", "researcher_3"],
 *   data: { label: "AI Safety collaboration", raw: { project: "AI Safety" } }
 * };
 */
export interface Hyperedge<T> {
  /** Unique hyperedge identifier */
  id: string;
  /** List of node IDs in this hyperedge (minimum 2) */
  linked_nodes: string[];
  /** Whether this hyperedge should be highlighted (persistent search result) */
  highlighted?: boolean;
  /** Hyperedge metadata with label and raw fields */
  data: {
    /** Display label */
    label: string;
    /** Original hyperedge data */
    raw: T;
    /** Additional properties */
    [key: string]: any;
  };
}

// ============================================================================
// Internal API Models
// ============================================================================

/**
 * JSON Schema representation for data types.
 * Generated by Pydantic's model_json_schema() method.
 */
export interface SchemaUnit {
  schema: Record<string, any>;
}

/**
 * Metadata response for /api/meta endpoint.
 * 
 * Provides visualization type, available features, and dynamic schemas.
 * The frontend uses this to:
 * 1. Route to the correct visualization component
 * 2. Enable/disable UI features (search, chat, etc.)
 * 3. Dynamically render property panels
 * 
 * @example
 * const meta = await fetch('/api/meta').then(r => r.json());
 * // {
 * //   type: "graph",
 * //   features: { search: true, chat: true },
 * //   schemas: {
 * //     nodes: { title: "Node", properties: {...} },
 * //     edges: { title: "Edge", properties: {...} }
 * //   }
 * // }
 */
export interface MetaResponse {
  /** Visualization type: determines which component to render */
  type: "graph" | "list" | "hypergraph";
  /** Feature availability flags (e.g., {"search": true, "chat": false}) */
  features: Record<string, boolean>;
  /** Map of element types to their JSON Schemas */
  schemas: Record<string, Record<string, any>>;
  /** Statistics about the data (e.g. node count, edge count) */
  stats: Record<string, any>;
}

/**
 * Search query request.
 */
export interface SearchRequest {
  /** Search query string */
  query: string;
  /** Optional context data passed to search callback */
  context?: Record<string, any>;
}

/**
 * Chat query request.
 */
export interface ChatRequest {
  /** User question or message */
  query: string;
  /** Optional context (conversation history, selected items, etc.) */
  context?: Record<string, any>;
}

/**
 * Chat response.
 */
export interface ChatResponse {
  /** Response text from LLM or callback */
  response: string;
  /** Optional list of source item IDs */
  sources?: string[];
}

/**
 * Complete visualization data payload for /api/data endpoint.
 * 
 * Returns raw data without type wrapping (type is known from /api/meta).
 * The actual response will be one of: GraphData, HypergraphData, or ListData
 */
export type VisualizationData = GraphData | HypergraphData | ListData;

export interface GraphData {
  /** List of nodes in the graph */
  nodes: Array<Node<any>>;
  /** List of edges connecting nodes */
  edges: Array<Edge<any>>;
}

export interface HypergraphData {
  /** List of nodes */
  nodes: Array<Node<any>>;
  /** List of regular edges (for layout) */
  edges: Array<Edge<any>>;
  /** List of hyperedges connecting multiple nodes */
  hyperedges: Array<{
    id: string;
    label: string;
    node_set: string[];
    data: any;
    highlighted?: boolean;
  }>;
}

export interface ListData {
  /** List of items */
  items: Array<Item<any>>;
  /** Current page number (0-indexed) */
  page?: number;
  /** Items per page */
  page_size?: number;
  /** Total number of items */
  total?: number;
  /** Whether there is a next page */
  has_next?: boolean;
}
