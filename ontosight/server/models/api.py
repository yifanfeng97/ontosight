"""Internal API response models for FastAPI endpoints.

These models define the JSON responses returned by the REST API.
They are distinct from the public models (Node, Edge, etc.) and serve
as contracts between frontend and backend.

Models:
    - SchemaUnit: JSON Schema representation
    - MetaResponse: Schema + metadata for visualization
    - SearchRequest: Search query input
    - SearchResponse: Search results (matching item IDs)
    - ChatRequest: Chat query input
    - ChatResponse: Chat response with optional sources
    - VisualizationData: Complete visualization payload

Example:
    >>> from ontosight.server.models.api import MetaResponse
    >>>
    >>> meta = MetaResponse(
    ...     node_schema={...},
    ...     edge_schema={...},
    ...     item_schema={...}
    ... )
"""

from typing import Any, Dict, List, Optional, Literal
from pydantic import BaseModel, ConfigDict, Field


class SchemaUnit(BaseModel):
    """JSON Schema representation for data types.

    Generated by Pydantic's model_json_schema() method.
    Contains type information, properties, required fields, etc.

    Attributes:
        schema_: Complete JSON Schema object (nested dict)
    """

    model_config = ConfigDict(populate_by_name=True)

    schema_: Dict[str, Any] = Field(..., alias="schema", description="JSON Schema object")


class MetaResponse(BaseModel):
    """Metadata response for /api/meta endpoint.

    Contains visualization type, available features, and schemas for data types.
    The frontend uses this to:
    1. Determine which visualization component to render
    2. Decide which UI features (search, chat) to enable
    3. Dynamically render property panels based on schemas

    Attributes:
        type: Visualization type (graph, list, or hypergraph)
        features: Dict of feature flags (e.g., {"search": true, "chat": false})
        schemas: Dict mapping element types to their JSON Schemas
                 For graph: {"nodes": {...}, "edges": {...}}
                 For list: {"items": {...}}
                 For hypergraph: {"nodes": {...}, "edges": {...}, "hyperedges": {...}}
    """

    type: Literal["graph", "list", "hypergraph"] = Field(
        ..., description="Type of visualization"
    )
    features: Dict[str, bool] = Field(
        default_factory=dict,
        description="Feature availability flags (e.g., search, chat)",
    )
    schemas: Dict[str, Dict[str, Any]] = Field(
        default_factory=dict,
        description="Map of element types to their JSON Schemas",
    )
    stats: Dict[str, Any] = Field(
        default_factory=dict,
        description="Statistics about the data (e.g. node count, edge count)",
    )


class SearchRequest(BaseModel):
    """Search query request model.

    Attributes:
        query: Search query string
        context: Optional context data passed to search callback
    """

    query: str = Field(..., description="Search query string", min_length=1)
    context: Optional[Dict[str, Any]] = Field(None, description="Optional context data")


class ChatRequest(BaseModel):
    """Chat query request model.

    Attributes:
        query: User question
        context: Optional context (conversation history, selected items)
    """

    query: str = Field(..., description="User question or message", min_length=1)
    context: Optional[Dict[str, Any]] = Field(
        None, description="Optional context (history, selections, etc.)"
    )


class ChatResponse(BaseModel):
    """Chat response model.

    Attributes:
        response: LLM response text
        sources: Optional list of source item IDs
    """

    response: str = Field(..., description="Response text")
    sources: Optional[List[str]] = Field(None, description="Optional list of source item IDs")


class GraphData(BaseModel):
    """Data for graph visualization."""
    nodes: List[Dict[str, Any]] = Field(..., description="List of node objects (may include 'highlighted' bool)")
    edges: List[Dict[str, Any]] = Field(..., description="List of edge objects (may include 'highlighted' bool)")


class HypergraphData(BaseModel):
    """Data for hypergraph visualization."""
    nodes: List[Dict[str, Any]] = Field(..., description="List of node objects (may include 'highlighted' bool)")
    edges: List[Dict[str, Any]] = Field(..., description="List of edge objects (for layout)")
    hyperedges: List[Dict[str, Any]] = Field(..., description="List of hyperedge objects (may include 'highlighted' bool)")


class ListData(BaseModel):
    """Data for list/table visualization."""
    items: List[Dict[str, Any]] = Field(..., description="List of items (may include 'highlighted' bool)")
    page: Optional[int] = Field(None, description="Current page number (0-indexed)")
    page_size: Optional[int] = Field(None, description="Items per page")
    total: Optional[int] = Field(None, description="Total number of items")
    has_next: Optional[bool] = Field(None, description="Whether there is a next page")


class VisualizationData(BaseModel):
    """Complete visualization data payload for /api/data endpoint.
    
    This is a type hint only - the actual response will be one of the data types below
    without additional wrapping, since type information is already provided by /api/meta.
    
    The response model for /api/data endpoint is not enforced at the type level;
    instead, it returns GraphData, HypergraphData, or ListData directly based on
    the visualization type stored in global_state.
    """
    pass  # Unused - for backwards compatibility only


__all__ = [
    "SchemaUnit",
    "MetaResponse",
    "SearchRequest",
    "ChatRequest",
    "ChatResponse",
    "GraphData",
    "HypergraphData",
    "ListData",
    "VisualizationData",
]
